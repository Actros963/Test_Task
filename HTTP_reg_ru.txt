	Когда пользователь вводит доменное имя (reg.ru), браузер проверяет список предзагруженных HSTS - список сайтов, которые требуют, чтобы к ним обращались только по HTTPS. 
В данном случае сайт есть в этом списке,браузер отправляет ему запрос через HTTPS. Далее браузер проверяет наличие домена в своём кэше. Если домена там нет, 
то браузер пытается найти нужный адрес в файле hosts. Если домен нигде не закэширован и отсутствует в файле hosts, отправляет запрос к сетевому DNS-серверу. Он использует DNS-серверы, 
указанные в сетевых настройках (156.154.70.25.), для поиска домена перврого уровня(ru), второго(reg), а затем спрашивает домен сервера имен для IP-адреса указанного субдомена (www).
После того, как браузер получил IP-адрес сервера от DNS, он может приступить к созданию запроса. Запрос содержит в себе заголовок и также может 
содержать тело запроса (например, данные из формы, которую отправил пользователь).
	Запрос содержит в себе следующие параметры:

	Request URL:https://www.reg.ru/    -   запрашиваемый URL
    Request method:GET				   -   метод запроса
    Remote address:194.58.116.31:443   -   IP - адрес конечного сервера и порт для HTTPS(443)
    Status code: 200 OK                -   код статуса HTTP (успешный запрос)
    Version:HTTP/2.0				   -   версия протокола HTTP
	
	Host: www.reg.ru
	User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:70.0) Gecko/20100101 Firefox/70.0
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
	Accept-Language: ru,en-US;q=0.7,en;q=0.3
	Accept-Encoding: gzip, deflate, br
	Connection: keep-alive
	Cookie: SESSION_ID=66c7853a8e531c33c5dc8e4500d4dc241e2dc026; transition_needs_saving=0; regru_utr=372328899200965129b172ca1d9c0969;
	_ga=GA1.2.1838762904.1569269371; _gid=GA1.2.465521585.1569269371; _ym_uid=1569269371944708188; _ym_d=1569269371; _ym_isad=2; _fbp=fb.1.1569269374359.1305383649;
	cto_lwid=c9fa189f-4ba9-41c0-b792-c4072729727b; tmr_detect=0%7C1569288211542; _ym_visorc_1379221=w; _gat=1
	Upgrade-Insecure-Requests: 1
	Cache-Control: max-age=0
	TE: Trailers
	

	Дополнительная информация представлена в виде пар ключ/значение, где ключ — это идентификатор, название,
а значения включают в себя информацию о браузере пользователя (user-agent), куки (cookies), хост (host), которое в данном случае является названием домена и т.д. 
	После того, как сервер получил запрос, он генерирует ответ:

	HTTP/2.0 200 OK
	server: nginx
	date: Tue, 24 Sep 2019 05:23:49 GMT
	content-type: text/html
	last-modified: Tue, 24 Sep 2019 04:10:36 GMT
	etag: W/"5d89973c-2bc4b"
	expires: Tue, 24 Sep 2019 05:53:49 GMT
	cache-control: max-age=1800
	content-encoding: gzip
	x-frame-options: Deny
	cache-control: no-cache, no-store
	x-content-type-options: nosniff
	x-xss-protection: 1; mode=block
	strict-transport-security: max-age=10886400; includeSubDomains; preload
	X-Firefox-Spdy: h2

После этого посылается пустая строка, а затем оставшийся контент HTML-страницы reg.ru.

После этого посылается пустая строка, а затем оставшийся контент HTML-страницы reg.ru. Если HTTP-заголовки отправленные веб-браузером включают информацию, которой серверу достаточно 
для определения версии файла, закэшированного в браузере и этот файл не менялся со времени последнего запроса, то ответ может принять следующую форму:
  304 Not Modified
  [заголовки ответа]
и, соответственно, клиенту не посылается никакого контента, вместо этого браузер «достаёт» HTML из кэша. 
После разбора HTML, браузер (и сервер) повторяет процесс загрузки для каждого ресурса (изображения, стили, скрипты, favicon.ico и так далее), на который ссылается HTML-страница.
Если HTML ссылается на ресурс, размещённый на домене, отличном от reg.ru то браузер возвращается к шагам, включающим разрешение доменного имени, а затем заново проходит процесс до
текущего состояния, но уже для другого домена. Заголовок Host в запросе вместо reg.ru будет установлен на нужное доменное имя.
Сервер разбирает запрос по следующим параметрам:
	Метод HTTP-запроса (GET, POST, HEAD, PUT или DELETE). В случае URL-адреса, который пользователь напечатал в строке браузера, мы имеем дело с GET-запросом.
Запрашиваемые пути/страницы... и т.д. Сервер находит контент, который соответствует запросу. Далее сервер разбирает («парсит») файл с помощью обработчика и направляет результат клиенту.
Поступаемый кусками по 8Кб контент рачинает парситься. Разметка HTML разбирается в дерево DOM-элементов и узлов атрибутов.  
После этого браузер начинает подгружать внешние ресурсы, связанные со страницей (стили, изображения, скрипты и так далее).
На этом этапе браузер помечает документ, как интерактивный и начинает разбирать скрипты, находящиеся в «отложенном» состоянии: то есть те из них, что должны быть 
исполнены после парсинга. После этого статус документа устанавливается в состояние «complete» и инициируется событие загрузки («load»).
Во время разбора браузер парсит CSS-файлы, содержимое тегов <style> и атрибутов «style» c помощью «лексической и синтаксической грамматики CSS».
Каждый CSS-файл разбирается в объект StyleSheet, каждый из таких объектов содержит правила CSS с селекторами и объектами в соответствии с грамматикой CSS.
Путём перебора DOM-узлов и вычисления для каждого узла значений CSS-стилей создаётся «Дерево рендера» (Render Tree или Frame Tree).
Вычисляется предпочтительная ширина каждого узла в нижней части дерева, реальная ширина каждого узла сверху-вниз. Вычисляется высота каждого узла снизу-вверх — для этого применяется перенос 
текста и суммируются значения полей, высоты, отступов и границ потомков. Вычисляются координаты каждого узла.
После завершения рендеринга, браузер исполняет JavaScript-код. Скрипты могут потребовать обработки дополнительных сетевых запросов, изменять страницу или её шаблон, что приведёт
к следующему этапу рендеринга и отрисовки.
После окончания процесса рендеринга пользователь видит отрисованную страницу с интерактивными элементами.




	